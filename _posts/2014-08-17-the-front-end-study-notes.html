---
layout: post
title: 前端学习笔记
subline: the front end study notes
categories: frontend
tags: [github-page, jekyll]
img: 3
---
<div class="banner-red">
	<img src="http://zhuowenli.qiniudn.com/wordpress/images/icon/infinity.svg" alt="Infinity" width="190">
</div>
<!--more-->
<p>持续更新中~</p>
<div>
	<h2>javascript</h2>

	<hr />
	<h3>基础</h3>

	<h4>语言特性</h4>
	<ul>
		<li>
			<p>数据类型：</p>
			<ul>
				<li><code>Undefined</code>，<code>Null</code>，<code>Bollean</code>，<code>Number</code>，<code>String</code></li>
				<li><code>Object</code>，<code>Array</code></li>
				<li><code>Date</code>，<code>RegExp</code></li>
			</ul>
		</li>
		<li>
			<p>typeof输出(以下6个值之一)：</p>
			<ul>
				<li>
					<code>undefined</code>						
					<div>
						<pre>
var x;
typeof(x); // "undefined"
						</pre>
					</div>
				</li>
				<li>
					<code>boolean</code>						
					<div>
						<pre>
var x = false;
typeof(x); // "boolean"
						</pre>
					</div>
				</li>
				<li>
					<code>string</code>						
					<div>
						<pre>
var x = '';
typeof(x); // "string"
						</pre>
					</div>
				</li>
				<li>
					<code>number</code>						
					<div>
						<pre>
var x = NaN;
typeof(x); // "number"
						</pre>
					</div>
				</li>
				<li>
					<code>object</code>						
					<div>
						<pre>
var x = {};
var y = [];
var z = null;
typeof(x); // "object"
typeof(y); // "object"
typeof(z); // "object"
						</pre>
					</div>
				</li>
				<li>
					<code>function</code>						
					<div>
						<pre>
var x = function(){};
typeof(x); // "function"
						</pre>
					</div>
				</li>
			</ul>
		</li>
	</ul>
	

	<h4>类型转换</h4>
	<ul>
		<li>
			<p>简单类型 -> 简单类型</p>
			<div>
				<pre>
'1'-0; //1, 等同于 Number('1')
				</pre>
			</div>
		</li>
		<li>
			<p>简单类型 -> 对象（使用基本函数的构造函数：Number(),String(),Boolean()等生成）</p>
			<div>
				<pre>
var n = 5;
console.log(n.toString(2)); //快速进制转换
				</pre>
			</div>
		</li>
		<li>
			<p>对象 -> 简单类型（参考<a href="http://www.ituring.com.cn/article/53351" title="【WEB前端】百度前端面试经历小研究1——JavaScript 类型转换" target="_black">JavaScript类型转换</a>）</p>
			<ul>
				<li>
					<p>隐式转换：除Date外，统统是先<code>valueOf</code>、再<code>toString</code>（<code>Date</code>在<code>+</code>和<code>==</code>时优先转化为字符串）</p>
					<div>
						<pre>
[] + 1; //1
						</pre>
					</div>
				</li>
				<li>
					<p>显式Number(对象)：先<code>valueOf</code>，再<code>toString()</code>，都不存在则返回<code>NaN</code></p>
					<div>
						<pre>
Number({}); //NaN
						</pre>
					</div>
				</li>
				<li>
					<p>显式String(对象)：先取<code>valueOf()</code>，再取<code>valueOf()</code>，都不存在则抛异常</p>
					<div>
						<pre>
String({}); //[Object Object]
						</pre>
					</div>
				</li>
			</ul>
		</li>
	</ul>
	

	<h4>DOM操作（增、删、改、查、移、数据交换）</h4>
	<ul>
		<li>
			<p><code>createElement</code>、<code>createTextNode</code>、<code>createDocuemntFragment</code>、<code>appendChild</code></p>
		</li>
		<li>
			<p><code>removeChild</code>、<code>removeNode</code></p>
		</li>
		<li>
			<p><code>getElementById</code>、<code>getElementsByTagName</code>、<code>getElementsByClassName</code>、<code>querySelector</code>、<code>querySlectorAll</code>、<code>parentNote</code>、<code>firstChild</code>、<code>lastChild</code>、<code>nextSibling</code>、<code>previousSibling</code>、<code>childNodes</code></p>
		</li>
		<li>
			<p><code>replaceChild</code>、<code>insertBefore</code></p>
		</li>
		<li>
			<p><code>getAttribute</code>、<code>setAttribute</code>、<code>data-x</code>、<code>jQuery.attr()</code>、<code>jQuery.prop()</code>、<code>jQuery.data()</code>、<code>classList</code>、<code>innerHTML</code>、<code>innerText</code>、<code>textContent</code></p>
		</li>
	</ul>
	

	<h4>事件机制（IE vs W3C）</h4>
	<ul>
		<li>
			<p>事件的绑定与解绑：<code>addEventListener(type,handler,flag)</code>、<code>attechEvent('on'+type,handler)</code>、<code>removeEventListener(type,handler)</code>、<code>detechEvent('on'+type,handler)</code></p>
		</li>
		<li>
			<p>事件流：</p>
			<ul>
				<li>
					<p>事件捕获流：沿着文档树由外到内</p>
				</li>
				<li>
					<p>事件对象</p>
					<div>
						<pre>
function handler(e){
	var e = e || window.event;
	var target = e.target || e.srcElement;
	// e.currentTarget 指的是绑定事件的元素，不一定和target是同一个
}
						</pre>
					</div>
				</li>
				<li>
					<p>事件冒泡流：沿着文档树由内到外，load、unload、focus、blur、submit和change事件不支持冒泡</p>
				</li>
			</ul>
		</li>
	</ul>
	

	<h4>OOP面向对象程序设计（原型链、继承...）</h4>
	<ul>
		<li>
			<p>比较（参考<a href="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/" title="全面理解面向对象的 JavaScript" target="_black">全面理解面向对象的 JavaScript</a>）</p>
			<ul>
				<li>
					<p>基于类<code>Class</code>的面向对象，对象由类<code>Class</code>产生：如<code>Java</code>、<code>C#</code></p>
				</li>
				<li>
					<p>javascript：基于原型<code>prototype</code>的OOP，对象由构造器（构造函数）<code>constructor</code>利用原型<code>prototype</code>产生</p>
				</li>
			</ul>
		</li>
		<li>
			<p>生成JS对象：</p>
			<ul>
				<li>
					<p>类JSON对象字面量：简单直观，但不适用于复杂的对象（类）</p>
					<div>
						<pre>
var Preson = {
	name : "xiaoming",
	age  : 15
}
						</pre>
					</div>
				</li>
				<li>
					构造函数模式：存在内存浪费的问题，比如下面例子里的this.city，在内存中会生成多次
					<div>
						<pre>
var Preson = function(name,age){
	//全部标记为私有成员
	this.name = name;
	this.age  = age;
	this.city = 'xia men';
};
var xm = new Preson("xiaoming",15);
var xl = new Preson("xiaoli",16);
						</pre>
					</div>
				</li>
				<li>
					<p>原型<code>prototype</code>模式：每次实例化只增加私有的对象属性（或方法）到实例中，所有实例的共有属性（或方法）指向同一个内存地址</p>
					<div>
						<pre>
var Preson = function(name,age){
	//对象的私有成员
	this.name = name;
	this.age  = age;
}
Preson.prototype.city = 'xia men';//共有成员
						</pre>
					</div>
				</li>
			</ul>
		</li>
		<li>
			<p>对象的继承</p>
			<ul>
				<li>
					<p>非构造函数的继承：继承可以简单使用对象之间的深、浅拷贝</p>
				</li>
				<li>
					<p>构造函数的继承：大多是基于原型的继承，但是阅读性差，也不利于扩展</p>
					<div>
						<ul>
							<li>
								<p>借调：依赖apply或者cell实现</p>
								<div>
									<pre>
function A(name){
	this.name = name;
}
function B(name,age){
	A.apply(this,arguments);
	this.age = age;
}
									</pre>
								</div>
							</li>
							<li>
								<p>子类<code>prototype</code>引用父类的<code>prototype</code></p>
								<div>
									<pre>
function A(){}
A.prototype.propA = 'a';
A.prototype.propB = 'b';
function B(){}
B.prototype = A.prototype; //原型链引用，改成 B.prototype = new A(); 可以解决引用的问题
B.prototype.propB = 'B';   //函数重载
B.prototype.constructor = B;
var b = new B();
									</pre>
									<p>A、B的<code>prototype</code>引用同一个地址，事实上A的prototype.constructor已经被改成了B</p>
								</div>
							</li>
							<li>
								<p>借用空函数的prototype，类似于YUI的实现</p>
								<div>
									<pre>
function extend(sub,sup){
	var _f = function(){};
	_f.prototype = sup.prototype;
	sub.prototype = new _f();
	sub.prototype.constructor = sub;
	sub.super = sup.prototype; // 保存原构造函数
	_f = null;
}
function A(){}
A.prototype.propA = 'a';
A.prototype.propB = 'b';
function B(){}
extend(B,A);
B.prototype.propA;  //"a"
									</pre>
									<p>构造函数的继承，重要的是了解原型链<code>prototype chain</code>，继承的基本就是原型链的拷贝或者引用</p>
									<p>理解原型链<code>prototype chain</code>：</p>
									<pre>
function A(){}
function B(){}
B.prototype = new A();
function C(x,y){}
C.prototype = new B();
var c = new C();

c.__proto__ === c.prototype;            //true
B.prototype.__proto__ === A.prototype;  //true
B.__proto__ === B.prototype;            //true
A.__proto__ === Function.prototype;     //true
A.prototype === Object.prototype;       //true
									</pre>
									<p><strong><i>proto属性</i></strong>：对象的<code>__proto__</code>指向<code>Object.prototype</code>，<code>Function</code>对象的<code>__proto__</code>指向构造函数<code>prototype</code>。</p>
								</div>
							</li>
						</ul>
					</div>
				</li>
				<li>
					<p>类式继承：本质上还是使用构造函数<code>prototype</code>，封装成类，典型的例子就是jQuery之父Jhon Resig的<a href="http://ejohn.org/blog/simple-javascript-inheritance/" title="Simple JavaScript Inheritance">Simple JavaSript Inheritance</a>，其他类库也有各自的实现</p>
					<div>
						<ul>
							<li>
								<p>Simple Inheritance的用法</p>
								<div>
									<pre>
var Person = Class.extend({
	init : function(gender){
	this.gender = gender;
	}
});
var Teacher = Person.extend({
	init : function(gender,name){
	this._super(gender);
	this.name = name;
	},
	role : 'teacher',
	speek : function(){
	console.log('Hello, I am a %s',this.role);
	}
});
var Student = Person.extend({
	init : function(gender,name){
	this._super(gender);
	this.name = name;
	},
	role : 'student',
	speek : function(){
	console.log('Hello, I am a %s',this.role);
	}
});
									</pre>
								</div>
							</li>
						</ul>
					</div>
				</li>
			</ul>
		</li>
	</ul>
	

	<h4>函数式编程、作用域、闭包、this</h4>
	<ul>
		<li>
			<p>实参、形参</p>
			<div>
				<pre>
foo(1,2);
function foo(a,b,c){
	console.log(argument.length); //2 实际传入的参数
	console.log(foo.length);      //3 期望传入的参数
}
				</pre>
			</div>
		</li>
		<li>
			<p>函数声明与函数表达式</p>
			<div>
				<pre>
function foo() {} //函数声明
var foor = function foo() {};  //函数表达式
				</pre>
				<p>执行顺序：解析器会率先读取函数声明，所以在任何代码执行前函数声明可用</p>
				<pre>
fn(2) // 4
function fn(n){console.log(n);}
fn(2) // 4
function fn(n){console.log(n*n);} // 重载
fn(2) // 4
var fn = new function(n){console.log(++n);} // 函数表达式，按照申明的顺序执行
fn(2) // 3
				</pre>
			</div>
		</li>
		<li>
			<p><code>arguments</code>、<code>callee</code>、<code>caller</code>、<code>apply</code>、<code>call</code></p>
			<ul>
				<li>
					<p><code>arguments</code>，类数组，类似的还有<code>NodeList</code>、<code>ClassList</code>等对象</p>
				</li>
				<li>
					<p><code>arguments.callee</code>，返回正在执行的<code>Function</code>对象的一个引用</p>
					<div>
						<pre>
function foo(n){
	console.log(arguments.callee.arguments.length);
	console.log(arguments.callee.length);
}
foo(1,2,3) // 分别打出3，1
						</pre>
					</div>
				</li>
				<li>
					<p><code>arguments.caller</code>，返回调用这个<code>Function</code>对象的<code>Function</code>对象的引用</p>
				</li>
				<li>
					<p><code>apply</code>和<code>call</code>，传参不同，功能相同，都是把<code>Function</code>对象绑定到另外一个对象上去执行，其内的this指向这个对象</p>
				</li>
			</ul>
		</li>
		<li>
			<p>作用域</p>
			<ul>
				<li>
					<p>函数的局部变量：函数形参、函数内部<code>var</code>声明的变量</p>
				</li>
				<li>
					<p>变量的查找（作用域链）：查找函数内部变量 -> 查找嵌套的外部函数 -> 查找window对象 -> 未定义</p>
				</li>
				<li>
					<p>javascript中没有块级作用域，可用匿名函数模拟</p>
				</li>
				<li>
					<p>未用关键字<code>var</code>声明的变量，会自动升级为全局变量挂到window上</p>
				</li>
				<li>
					<p>顶级作用域内使用<code>var</code>声明的变量是window对象的一个属性</p>
				</li>
			</ul>
		</li>
		<li>
			<p>闭包</p>
			<ul>
				<li>由于作用域的限制，函数外部不能访问函数内部的局部变量</li>
				<li>
					<p>闭包就是能够读取其他函数内部变量的函数<i>引自<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" title="阮一峰学习Javascript闭包（Closure）">学习Javascript闭包</a></i></p>
					<div>
						<pre>
function foo(){
	var x = 1;
	return function fn(){ // 闭包
	return x;
	}
}
var bar = foo();
console.log(bar());
						</pre>
					</div>
				</li>
				<li>闭包的另一个作用是在内存中保存函数的局部变量，这有可能导致内存泄漏</li>
			</ul>
		</li>
		<li>
			<p>this：函数中的<code>this</code>始终指向函数的调用者</p>
			<div>
				<pre>
function foo(x){
	this.x = x;
}
foo(1) // 调用者是window，也可以说window.foo()
console.log(window.x); // 1

var o = {}
o.foo = foo;
o.foo(2); // 调用者是o
console.log(o.x); // 2
console.log(window.x); // 1
				</pre>
			</div>
		</li>
	</ul>
	

	<h4>Ajax(XMLHttpRequest ActiveXObject)</h4>
	<ul>
		<li>
			<p>请求过程</p>
			<ul>
				<li>
					<p>建立到服务器的新请求：<code>xhr.open()</code></p>
				</li>
				<li>
					<p>向服务器发送请求：<code>xhr.send()</code></p>
				</li>
				<li>
					<p>退出当前请求：<code>xhr.abort()</code></p>
				</li>
				<li>
					<p>查询当前<code>HTML</code>的就绪状态：<code>xhr.readyState</code></p>
				</li>
				<li>
					<p>服务器返回的请求响应文本：<code>xhr.responseText</code></p>
				</li>
			</ul>
		</li>
		<li>
			<p>RUST API：<code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>DELETE</code></p>
			<ul>
				<li>GET：更多用于<strong>读</strong>操作，参数暴露到url,（服务器端可能对）url长度有限制</li>
				<li>POST：更多用于<strong>写</strong>操作</li>
			</ul>
		</li>
		<li>
			<p>HTTP状态码</p>
		</li>
		<li>
			<p>XHR2</p>
		</li>
	</ul>
	

	<h4>跨域问题</h4>
	<ul>
		<li>
			<p>跨域的形成（同源限制）：主域、子域、ip和域名、协议不同、端口不同</p>
		</li>
		<li>
			<p>常用的解决方案</p>
			<ul>
				<li>
					<p>
						<strong>iframe+document.domain</strong>：适用于跨子域的情况 <br>
						缺点是如果一个域名下存在安全问题，另一个域名下可能也会出现问题，还有就是创建iframe的开销
					</p>
				</li>
				<li>
					<p><strong>动态引入js脚本</strong>：适合所有的跨域场景 <br>
						引入的脚本会立刻执行，存在安全问题 <br>
						要与远端沟通约定变量，增加了开发和维护成本
					</p>
				</li>
				<li>
					<p><strong>iframe+location.hash</strong>：适合各种场景下跨域 <br>
						iframe嵌套引用，开销更大 <br>
						会产生历史记录，url中暴露传递的内容
					</p>
				</li>
				<li>
					<p><strong>iframe+window.name</strong>：使用iframe的window.name从外域传递数据到本地域，使用各种场景下跨域，且数据安全 <br>
						缺点是数据大小有限制
					</p>
				</li>
				<li>
					<p><code>postMessage</code>跨域通讯</p>
				</li>
			</ul>
		</li>
	</ul>
		
	<h4>jQuery</h4>	
	<p>可阅读元彦童鞋的<a href="https://github.com/yuanyan/pragmatic-jquery" title="jQuery 编程实践">jQuery 编程实践</a></p>

	<h4>安全问题</h4>
	<ul>
		<li>
			<p>XSS</p>
		</li>
		<li>
			<p>CSRF</p>
		</li>
		<li>
			<p>SQL注入</p>
		</li>
		<li>
			<p>敏感信息采用安全传输（SSL/HTTPS）</p>
		</li>
		<li>
			<p>上传限制（大小、mime类型、可执行文件）</p>
		</li>
		<li>
			<p>（服务器端）严格的路径模式，比如杜绝路径跳转</p>
		</li>
	</ul>


	<h2>CSS</h2>	
	<hr />
	<ul>
		<li>
			<p>css盒模型</p>
		</li>
		<li>
			<p>css继承规则</p>
		</li>
		<li>
			<p>IE低版本hack</p>
		</li>
		<li>
			<p>浏览器的怪异模式与标准模式</p>
		</li>
	</ul>

	<h2>性能优化（最佳实践）</h2>
	<hr />

	<h4>HTML优化</h4>
	<ul>
		<li>
			<p>语义化<code>HTML</code>结构：SEO友好，利于维护</p>
		</li>
	</ul>
</div>